# -*- coding: utf-8 -*-
"""spam_classification_api.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1zhG-KmMrqpdTP-dfJpW2u91hE0GbkG1U
"""

from fastapi import FastAPI, HTTPException , Request
from pydantic import BaseModel
import joblib
from fastapi.middleware.cors import CORSMiddleware
from fastapi.staticfiles import StaticFiles
from fastapi.templating import Jinja2Templates

# ================================
# Load models at startup
# ================================
models = {
    "count-naive-bayes": joblib.load("models/nb_count.pkl"),
    "tfidf-naive-bayes": joblib.load("models/nb_tfidf.pkl"),
    "count-logistic-regression": joblib.load("models/lr_count.pkl"),
    "tfidf-logistic-regression": joblib.load("models/lr_tfidf.pkl"),
    "count-random-forest": joblib.load("models/rf_count.pkl"),
    "tfidf-random-forest": joblib.load("models/rf_tfidf.pkl"),
    "count-gradient-boost": joblib.load("models/gb_count.pkl"),
    "tfidf-gradient-boost": joblib.load("models/gb_tfidf.pkl"),
}
vectorizers = {
    "count": joblib.load("vectorizers/count.pkl"),
    "tfidf": joblib.load("vectorizers/tfidf.pkl"),
}

# ================================
# FastAPI App
# ================================
app = FastAPI(title="Spam Classification")
 #Serve static files
#app.mount("/static", StaticFiles(directory="static"), name="static")

# Set up templates
#templates = Jinja2Templates(directory="templates")

# Root endpoint renders index.html template
#@app.get("/")
#def read_root(request: Request):
 #   return templates.TemplateResponse("index.html", {"request": request})
# ---- CORS ----
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)
# ================================
# Request Schema
# ================================
class SpamRequest(BaseModel):
    message: str
    model: str


# ================================
# Prediction Endpoint
# ================================
@app.post("/predict")
def predict(request: SpamRequest):

    model_name = request.model.lower()


    if model_name not in models:
        raise HTTPException(
            status_code=400,
            detail=f"Invalid model. Choose from {list(models.keys())}"
        )


    mod = models[model_name]
    if "count" in  model_name:
        vect = vectorizers["count"]
    else:
        vect = vectorizers["tfidf"]

    X = vect.transform([request.message])
    prediction = mod.predict(X)[0]

    response = {
        "model": model_name,

        "prediction": "Spam" if prediction == 1 else "Ham"
    }

    if hasattr(mod, "predict_proba"):
        response["spam_probability"] = round(
            float(mod.predict_proba(X)[0][1]), 4
        )

    return response


# ================================
# List available models
# ================================
@app.get("/models")
def list_models():
    return {"available_models": list(models.keys())}


# ================================
# Health Check
# ================================
@app.get("/health")
def health_check():
    return {"message": "SPAM CLASSIFICATION is running"}